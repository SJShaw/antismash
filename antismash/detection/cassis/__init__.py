# License: GNU Affero General Public License v3 or later
# A copy of GNU AGPL v3 should have been included in this software package in LICENSE.txt.

"""Implementation of the CASSIS method for the motif-based prediction of SM gene clusters"""

import csv
import logging
import os
import shutil
from typing import Any, Dict, List, Set, Tuple, Union
from xml.etree import cElementTree as ElementTree

from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.SeqFeature import SeqFeature

from antismash.common import path, module_results
from antismash.common.secmet.feature import ClusterBorder, Feature, FeatureLocation, GeneFunction
from antismash.common.secmet.record import Record
from antismash.config.args import ModuleArgs

from .runners import run_fimo, run_meme

NAME = "cassis"
SHORT_DESCRIPTION = "Detect secondary metabolite gene cluster (motif based)"

MAX_PERCENTAGE = 14.  # the maximum percentage of promoters sharing a motif
MAX_GAP_LENGTH = 2  # the maximum gap length between islands

VERBOSE_DEBUG = False  # whether to show all debugging info or not


class CassisResults(module_results.ModuleResults):
    """ Contains the borders predicted by cassis """
    def __init__(self, record_id: str, borders: List[ClusterBorder]) -> None:
        super().__init__(record_id)
        self.borders = borders

    def to_json(self, *args) -> Dict[str, Any]:
        return {}

    @staticmethod
    def from_json(*args) -> "CassisResults":
        return None

    def add_to_record(self, record) -> None:
        pass

    def get_predictions(self) -> List[ClusterBorder]:
        return self.borders


def get_arguments() -> ModuleArgs:
    """ Build and return arguments. No extra options beyond a switch to enable """
    args = ModuleArgs('Additional analysis', 'cassis')
    args.add_analysis_toggle('--cassis',
                             dest='cassis',
                             action='store_true',
                             default=False,
                             help="Motif based prediction of SM gene clusters.")
    return args


def is_enabled(options) -> bool:
    """ Is the module enabled """
    return options.cassis


def check_options(options) -> List[str]:
    """ Make sure the options are sane """
    problems = []
    if options.taxon != "fungi" and is_enabled(options):
        problems.append("CASSIS cluster border prediction only works for fungal sequences.")
    return problems


def regenerate_previous_results(previous, record: Record, options):
    """ Rebuild the previous run results from a JSON object into this module's
        python results class.

        Arguments:
            previous: the previous results as a dictionary
            record: the Record that was used to generate the previous results
            options: an antismash.Config object
    """
    logging.critical("always skipping results regeneration for cassis")
    return None


def run_on_record(record: Record, results, options):
    """ Run this module's analysis section on the given record or use the
        previous results.

        Arguments:
            record: the Record instance to analyse
            results: the previous results as generated by regenerate_previous_results()
            options: an antismash.Config object

        Returns:
            this module's results as a subclass of
                antismash.common.module_results.ModuleResults
    """
    borders = detect(record, options)
    logging.debug("Cassis detected %d cluster border(s)", len(borders))
    for border in borders:
        record.add_cluster_border(border)
    return CassisResults(record.id, borders)


class AntiSmashError(RuntimeError):
    '''Base class for all antiSMASH custom errors'''
    pass


class InvalidLocationError(AntiSmashError):
    '''Thrown when running into invalid gene locations during runtime'''
    pass


class DuplicatePromoterError(AntiSmashError):
    '''Thrown when running into valid but duplicate promoter sequences during runtime'''
    pass


# all possible promoter sets for motif detection
# plus --> include <plus> promoters downstream the anchor gene's promoter
# minus --> include <minus> promoters upstream the anchor gene's promoter
_plus_minus = []
for plus in range(16):
    for minus in range(16):
        if plus + minus + 1 >= 4:
            _plus_minus.append({"plus": plus, "minus": minus})


def check_prereqs():
    """Check for prerequisites"""
    failure_messages = []
    for binary_name, _ in [("meme", "4.11.1"), ("fimo", "4.11.1")]:
        if path.locate_executable(binary_name) is None:
            failure_messages.append("Failed to locate executable for {!r}".format(binary_name))
        # TODO: Check binary version here

    return failure_messages


class Promoter:
    """ Contains all the relevant info and helpers for promoters """
    def __init__(self, gene_name: str, start: int, end: int, seq: Union[Seq, str] = None) -> None:
        self.gene_name = str(gene_name)
        self.start = int(start)
        self.end = int(end)
        self.seq = seq

    def get_id(self) -> str:
        """ Returns the id of the promoter """
        return self.gene_name

    def get_gene_names(self) -> List[str]:
        """ Returns a list of gene names attached to this promoter """
        return [self.gene_name]

    def __len__(self) -> int:
        if self.seq is None:
            raise ValueError("Requesting length of a promoter sequence which hasn't been set")
        return len(self.seq)


class CombinedPromoter(Promoter):
    """ A promoter class for cases where two genes are involved """
    def __init__(self, first_gene: str, second_gene: str, start: int, end: int, seq: Union[Seq, str] = None) -> None:
        super().__init__(first_gene, start, end, seq=seq)
        self.second_gene = str(second_gene)

    def get_id(self) -> str:
        return "{}+{}".format(self.gene_name, self.second_gene)

    def get_gene_names(self) -> List[str]:
        return super().get_gene_names() + [self.second_gene]


class Island:
    def __init__(self, start: int, end: int, motifs) -> None:
        self.start = int(start)
        self.end = int(end)
        self.motifs = motifs


# helper methods
def mprint(plus, minus) -> str:
    """Motif-print: nicely format motif name in plus/minus style"""
    return "+{:02d}_-{:02d}".format(plus, minus)


# main method
def detect(record: Record, options) -> List[ClusterBorder]:
    """Use core genes (anchor genes) from hmmdetect as seeds to detect gene clusters"""
    logging.info("Detecting gene clusters using CASSIS")

    # get core genes from hmmdetect --> necessary CASSIS input, aka "anchor genes"
    anchor_genes = get_anchor_genes(record)
    logging.info("Record has %d anchor genes", len(anchor_genes))
    if not anchor_genes:
        return []

    # filter all genes in record for neighbouring genes with overlapping annotations
    genes = record.get_genes()
    logging.info("Record has %d features of type 'gene'", len(genes))
    if not genes:
        return []
    genes, ignored_genes = ignore_overlapping(genes)

    # compute promoter sequences/regions --> necessary for motif prediction (MEME and FIMO input)
    promoters = []
    try:
        # why these values? see "Wolf et al (2015): CASSIS and SMIPS ..."
        upstream_tss = 1000  # nucleotides upstream TSS
        downstream_tss = 50  # nucleotides downstream TSS
        promoters = get_promoters(record, genes, upstream_tss, downstream_tss)
        write_promoters_to_file(record.name, options.output_dir, promoters)
    except (InvalidLocationError, DuplicatePromoterError):
        logging.error("CASSIS discovered an error while working on the promoter sequences, skipping CASSIS analysis")
        return []

    if not promoters:
        logging.debug("CASSIS found zero promoter regions, skipping CASSIS analysis")
        return []
    elif len(promoters) < 3:
        logging.debug("Sequence %r yields less than 3 promoter regions, skipping CASSIS analysis", record.name)
        return []
    elif len(promoters) < 40:
        logging.debug("Sequence %r yields only %d promoter regions", record.name, len(promoters))
        logging.debug("Cluster detection on small sequences may lead to incomplete cluster predictions")

    store_promoters(promoters, record)

    predicted_borders = []
    cluster_predictions = {}  # {anchor gene: cluster predictions}
    for i, anchor in enumerate(anchor_genes):
        logging.debug("Detecting cluster around anchor gene %r (%d of %d)", anchor, i + 1, len(anchor_genes))

        anchor_promoter = get_anchor_promoter(anchor, promoters)
        if anchor_promoter is None:
            logging.debug("No promoter region for %r, skipping this anchor gene", anchor)
            continue

        # predict motifs with MEME ("de novo")
        meme_dir = os.path.join(options.output_dir, "meme", anchor)
        promoter_sets = get_promoter_sets(meme_dir, anchor_promoter, promoters)
        exit_code = run_meme(meme_dir, options, VERBOSE_DEBUG)
        if exit_code != 0:
            logging.warning("MEME discovered a problem (exit code %d), skipping this anchor gene", exit_code)
            continue
        motifs = filter_meme_results(meme_dir, promoter_sets, anchor)

        if not motifs:
            logging.debug("Could not predict motifs around %r, skipping this anchor gene", anchor)
            continue

        # search motifs with FIMO ("scanning")
        fimo_dir = os.path.join(options.output_dir, "fimo", anchor)
        exit_code = run_fimo(meme_dir, fimo_dir, record, options, VERBOSE_DEBUG)
        if exit_code != 0:
            logging.warning("FIMO discovered a problem (exit code %d), skipping this anchor gene", exit_code)
            continue
        motifs = filter_fimo_results(motifs, fimo_dir, promoters, anchor_promoter)

        if not motifs:
            logging.debug("Could not find motif occurrences for %r, skipping this anchor gene", anchor)
            continue

        # TODO SiTaR (http://bioinformatics.oxfordjournals.org/content/27/20/2806):
        # Alternative to MEME and FIMO. Part of the original CASSIS implementation.
        # No motif prediction (no MEME). Motif search with SiTaR (instead if FIMO).
        # Have to provide a file in FASTA format with binding site sequences of at least one transcription factor.
        # Will result in binding sites per promoter (like FIMO) --> find islands
        #
        # implement: YES? NO?

        # find islands of binding sites around anchor gene
        islands = get_islands(anchor_promoter, motifs, promoters)
        logging.debug("%d possible cluster predictions for %r", len(islands), anchor)

        # return cluster predictions sorted by border abundance
        # (most abundant --> "best" prediction)
        cluster_predictions[anchor] = sort_by_abundance(islands)
        cluster_predictions[anchor] = check_cluster_predictions(cluster_predictions[anchor], record, promoters, ignored_genes)

        predicted_borders.extend(create_cluster_borders(anchor, cluster_predictions[anchor], record))

    logging.debug("Cleaning up MEME and FIMO output directories")
    cleanup_outdir(anchor_genes, cluster_predictions, options)
    return predicted_borders


# additional methods
def get_anchor_genes(record: Record) -> List[str]:
    """ Finds all gene names that have a CDS with secondary metabolite
        annotations.

        Requires that a CDS.get_name() returns the same name of its parent
        Gene.get_name()

        Arguments:
            record: the record to search

        Returns:
            a list of gene names
    """
    anchor_genes = []

    for feature in record.get_cds_features():
        if feature.gene_function == GeneFunction.CORE:
            anchor_genes.append(feature.get_name())

    return anchor_genes


def ignore_overlapping(genes):
    """Ignore genes with overlapping locations (skip the second gene of an overlapping couple)"""
    ignored = []

    overlap = True
    while overlap:  # check again until we didn't find any overlap in the entire (remaining) gene list
        overlap = False
        non_overlapping = [genes[0]]

        for i in range(1, len(genes)):
            if genes[i-1].overlaps_with(genes[i]):
                logging.debug("Ignoring %r (overlapping with %r)",
                             genes[i].get_name(), genes[i-1].get_name())
                ignored.append(genes[i])
                overlap = True
            else:
                non_overlapping.append(genes[i])

        genes = non_overlapping

    if ignored:
        logging.debug("Ignoring %d genes due to overlapping locations", len(ignored))

    return (genes, ignored)


def write_promoters_to_file(output_dir: str, prefix: str, promoters: List[Promoter]) -> None:

    # positions file
    pos_handle = open(os.path.join(output_dir, prefix + "_promoter_positions.csv"), "w")
    pos_handle.write("\t".join(["#", "promoter", "start", "end", "length"]) + "\n")
    # sequences file
    seq_handle = open(os.path.join(output_dir, prefix + "_promoter_sequences.fasta"), "w")

    for i, promoter in enumerate(promoters):
        # write promoter positions to file
        pos_handle.write("\t".join(map(str, [i + 1, promoter.get_id(),
                                             promoter.start + 1, promoter.end + 1,
                                             len(promoter)])) + "\n")

        # write promoter sequences to file
        SeqIO.write(SeqRecord(promoter.seq, id=promoter.get_id(),
                    description="length={}bp".format(len(promoter))),
                    seq_handle,
                    "fasta")


def get_promoters(record: Record, genes, upstream_tss: int, downstream_tss: int) -> List[Promoter]:
    """Compute promoter sequences for each gene in the sequence record"""
    logging.debug("Computing promoter sequences")

    min_promoter_length = 6
    max_promoter_length = (upstream_tss + downstream_tss) * 2 + 1

    record_seq_length = len(record.seq)
    promoters = []
    invalid = 0

    skip = False  # helper var for shared promoter of bidirectional genes
    for i, gene in enumerate(genes):

        if skip:  # two genes share the same promotor --> did computation with first gene, skip second gene
            skip = False
            # TODO: should this have a continue?

        elif len(genes) == 1:  # only one gene within record
            if gene.location.strand == 1:
                # 1 (for explanation of these numbers see file promoterregions.png)
                if (gene.location.start - upstream_tss >= 0
                        and gene.location.end > gene.location.start + downstream_tss):
                    # fuzzy (>|<) gene locations will be transformed to exact promoter locations
                    # we could save the fuzzy locations for promoters, too, via a FeatureLocation object
                    # but we use/calculate with the exact promoter locations anyway, here and later on
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.start + downstream_tss))
                # 2
                elif (gene.location.start - upstream_tss < 0
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), 0, gene.location.start + downstream_tss))
                # 3
                elif (gene.location.start - upstream_tss >= 0
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.end))
                # 7
                elif (gene.location.start - upstream_tss < 0
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), 0, gene.location.end))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

            elif gene.location.strand == -1:
                # 4
                if (gene.location.start < gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss <= record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, gene.location.end + upstream_tss))
                # 5
                elif (gene.location.start < gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss > record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, record_seq_length))
                # 6
                elif (gene.location.start >= gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss <= record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, gene.location.end + upstream_tss))
                # 8
                elif (genes[i+1].location.start >= gene.location.end - upstream_tss
                        and gene.location.end + upstream_tss > record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, record_seq_length))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

        # first gene of the record AND NOT special case #9
        elif (i == 0 and not (gene.location.strand == -1
                              and genes[i+1].location.strand == 1
                              and gene.location.end + upstream_tss >= genes[i+1].location.start - upstream_tss)):
            if gene.location.strand == 1:
                # 1
                if (gene.location.start - upstream_tss >= 0
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.start + downstream_tss))
                # 2
                elif (gene.location.start - upstream_tss < 0
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), 0, gene.location.start + downstream_tss))
                # 3
                elif (gene.location.start - upstream_tss >= 0
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.end))
                # 7
                elif (gene.location.start - upstream_tss < 0
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), 0, gene.location.end))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

            elif gene.location.strand == -1:
                # 4
                if (gene.location.start < gene.location.end - downstream_tss
                        and genes[i+1].location.start > gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, gene.location.end + upstream_tss))
                # 5
                elif (gene.location.start < gene.location.end - downstream_tss
                        and genes[i+1].location.start <= gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, genes[i+1].location.start - 1))
                # 6
                elif (gene.location.start >= gene.location.end - downstream_tss
                        and genes[i+1].location.start > gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, gene.location.end + upstream_tss))
                # 8
                elif (genes[i+1].location.start <= gene.location.end + upstream_tss
                        and gene.location.start >= gene.location.end - downstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, genes[i+1].location.start - 1))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

        # last gene of record
        elif i == len(genes) - 1 and not skip:
            if gene.location.strand == 1:
                # 1
                if (genes[i-1].location.end < gene.location.start - upstream_tss
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.start + downstream_tss))
                # 2
                elif (genes[i-1].location.end >= gene.location.start - upstream_tss
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), genes[i-1].location.end + 1, gene.location.start + downstream_tss))
                # 3
                elif (genes[i-1].location.end < gene.location.start - upstream_tss
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.end))
                # 7
                elif (genes[i-1].location.end >= gene.location.start - upstream_tss
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), genes[i-1].location.end + 1, gene.location.end))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

            elif gene.location.strand == -1:
                # 4
                if (gene.location.start < gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss <= record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, gene.location.end + upstream_tss))
                # 5
                elif (gene.location.start < gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss > record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, record_seq_length))
                # 6
                elif (gene.location.start >= gene.location.end - downstream_tss
                        and gene.location.end + upstream_tss <= record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, gene.location.end + upstream_tss))
                # 8
                elif (genes[i+1].location.start <= gene.location.end + upstream_tss
                        and gene.location.end + upstream_tss > record_seq_length):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, record_seq_length))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

        # special-case 9, bidirectional promoters
        elif (gene.location.strand == -1
                and genes[i+1].location.strand == 1
                and gene.location.end + upstream_tss >= genes[i+1].location.start - upstream_tss):
            # 9 (1+4)
            if (gene.location.end > gene.location.start + downstream_tss
                    and gene.location.start < gene.location.end - downstream_tss):
                promoters.append(CombinedPromoter(gene.get_name(), genes[i+1].get_name(), gene.location.end - downstream_tss, genes[i+1].location.start + downstream_tss))
            # 9 (3+4)
            elif (gene.location.start < gene.location.end - downstream_tss
                    and genes[i+1].location.start + downstream_tss >= genes[i+1].location.end):
                promoters.append(CombinedPromoter(gene.get_name(), genes[i+1].get_name(), gene.location.end - downstream_tss, genes[i+1].location.end))
            # 9 (1+6)
            elif (gene.location.start >= gene.location.end - downstream_tss
                    and genes[i+1].location.end > genes[i+1].location.start + downstream_tss):
                promoters.append(CombinedPromoter(gene.get_name(), genes[i+1].get_name(), gene.location.start, genes[i+1].location.start + downstream_tss))
            # 9 (3+6)
            elif (gene.location.start >= gene.location.end - downstream_tss
                    and genes[i+1].location.start + downstream_tss >= genes[i+1].location.end):
                promoters.append(CombinedPromoter(gene.get_name(), genes[i+1].get_name(), gene.location.start, genes[i+1].location.end))
            else:
                logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                raise InvalidLocationError

            skip = True

        # "normal" cases
        elif not skip:
            if gene.location.strand == 1:
                # 1
                if (genes[i-1].location.end < gene.location.start - upstream_tss
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.start + downstream_tss))
                # 2
                elif (genes[i-1].location.end >= gene.location.start - upstream_tss
                        and gene.location.end > gene.location.start + downstream_tss):
                    promoters.append(Promoter(gene.get_name(), genes[i-1].location.end + 1, gene.location.start + downstream_tss))
                # 3
                elif (genes[i-1].location.end < gene.location.start - upstream_tss
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), gene.location.start - upstream_tss, gene.location.end))
                # 7
                elif (genes[i-1].location.end >= gene.location.start - upstream_tss
                        and gene.location.start + downstream_tss >= gene.location.end):
                    promoters.append(Promoter(gene.get_name(), genes[i-1].location.end + 1, gene.location.end))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

            elif gene.location.strand == -1:
                # 4
                if (gene.location.start < gene.location.end - downstream_tss
                        and genes[i+1].location.start > gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, gene.location.end + upstream_tss))
                # 5
                elif (gene.location.start < gene.location.end - downstream_tss
                        and genes[i+1].location.start <= gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.end - downstream_tss, genes[i+1].location.start - 1))
                # 6
                elif (gene.location.start >= gene.location.end - downstream_tss
                        and genes[i+1].location.start > gene.location.end + upstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, gene.location.end + upstream_tss))
                # 8
                elif (genes[i+1].location.start <= gene.location.end + upstream_tss
                        and gene.location.start >= gene.location.end - downstream_tss):
                    promoters.append(Promoter(gene.get_name(), gene.location.start, genes[i+1].location.start - 1))
                else:
                    logging.error("BUG: Problem with promoter of gene %r", gene.get_name())
                    raise InvalidLocationError

        # negative start position or stop position "beyond" record --> might happen in very small records
        if promoters[-1].start < 0:
            promoters[-1].start = 0
        if promoters[-1].end > record_seq_length - 1:
            promoters[-1].end = record_seq_length - 1

        # write promoter positions and sequences to file
        if not skip:
            promoter_sequence = record.seq[promoters[-1].start:promoters[-1].end + 1]
            promoter_length = len(promoter_sequence)

            invalid_promoter_sequence = ""

            # check if promoter length is valid
            if promoter_length < min_promoter_length or promoter_length > max_promoter_length:
                invalid_promoter_sequence = "length"

            # check if a, c, g and t occur at least once in the promoter sequence
            elif "A" not in promoter_sequence.upper():
                invalid_promoter_sequence = "A"
            elif "C" not in promoter_sequence.upper():
                invalid_promoter_sequence = "C"
            elif "G" not in promoter_sequence.upper():
                invalid_promoter_sequence = "G"
            elif "T" not in promoter_sequence.upper():
                invalid_promoter_sequence = "T"

            if invalid_promoter_sequence:
                invalid += 1

                if invalid_promoter_sequence == "length":
                    logging.warning("Promoter %r is invalid (length is %s)",
                                    promoters[-1].get_id(), promoter_length)
                else:
                    # especially SiTaR doesn't like such missings
                    logging.warning("Promoter %r is invalid (sequence without %r)",
                                    promoters[-1].get_id(), invalid_promoter_sequence)

                # more details for debug logging
                logging.debug("Invalid promoter %r\n start %s\n end %s\n length %s\n",
                              promoters[-1].get_id(), promoters[-1].start,
                              promoters[-1].end, promoter_length)

                promoters.pop()  # remove last (invalid!) promoter

            else:
                promoters[-1].seq = promoter_sequence

        # check if promoter IDs are unique
        if len(promoters) >= 2 and promoters[-1].get_id() == promoters[-2].get_id():
            logging.error("Promoter %r occurs at least twice. This may be caused by overlapping gene annotations",
                          promoters[-1].get_id())
            raise DuplicatePromoterError

    if invalid:
        logging.debug("Ignoring %d promoters due to invalid promoter sequences", invalid)

    logging.debug("Found %d promoter sequences for %d genes", len(promoters), len(genes))
    return promoters


def get_anchor_promoter(anchor, promoters):
    """Find the name of the promoter which includes the anchor gene"""
    # the promoter ID is not (necessarily) equal to the anchor ID!
    for i, promoter in enumerate(promoters):
        if anchor in promoter.get_gene_names():
            return i

    return None


def get_promoter_sets(meme_dir: str, anchor_promoter, promoters):
    """Prepare sets of promoter sequences and motif subdirectories"""
    promoter_sets = []

    if not os.path.exists(meme_dir):
        os.makedirs(meme_dir)

    # prepare sets of promoter sequences (MEME input)
    indices = set()  # type: Set[Tuple[int, int]] # to monitor unique start_index/end_index
    for pm in _plus_minus:
        start_index = anchor_promoter - pm["minus"]
        end_index = anchor_promoter + pm["plus"]

        if start_index < 0:  # anchor promoter near beginning of record --> truncate
            if VERBOSE_DEBUG:
                logging.debug("Promoter set " + mprint(pm["plus"], pm["minus"]) + " exceeds upstream record border")
            start_index = 0

        if end_index > len(promoters) - 1:  # anchor promoter near end of record --> truncate
            if VERBOSE_DEBUG:
                logging.debug("Promoter set " + mprint(pm["plus"], pm["minus"]) + " exceeds downstream record border")
            end_index = len(promoters) - 1

        # discard promoter sets, which reappear due to truncation
        if (start_index, end_index) not in indices:
            indices.add((start_index, end_index))

            # check (again, compare init of _plus_minus) if the promoter set has at least 4 promoters
            if end_index - start_index + 1 >= 4:
                promoter_sets.append({"plus": pm["plus"], "minus": pm["minus"], "score": None})

                pm_dir = os.path.join(meme_dir, mprint(pm["plus"], pm["minus"]))
                if not os.path.exists(pm_dir):
                    os.makedirs(pm_dir)

                # write promoter sequences to fasta file, in respective "plus-minus" subdir
                with open(os.path.join(pm_dir, "promoters.fasta"), "w") as pm_handle:
                    for i in range(start_index, end_index + 1):
                        seq = SeqRecord(promoters[i].seq,
                                        id=promoters[i].get_id(),
                                        description="length={}bp".format(len(promoters[i].seq)))
                        if i == anchor_promoter:  # mark anchor gene
                            seq.id += "__ANCHOR"  # must be part of id, otherwise MEME woun't recognize it
                        SeqIO.write(seq, pm_handle, "fasta")
            else:
                if VERBOSE_DEBUG:
                    logging.debug("Too short promoter set " + mprint(pm["plus"], pm["minus"]))
        else:
            if VERBOSE_DEBUG:
                logging.debug("Duplicate promoter set " + mprint(pm["plus"], pm["minus"]))

    return promoter_sets


def filter_meme_results(meme_dir: str, promoter_sets, anchor):
    """Analyse and filter MEME results"""
    for motif in promoter_sets:
        xml_file = os.path.join(meme_dir, mprint(motif["plus"], motif["minus"]), "meme.xml")
        e = ElementTree.parse(xml_file).getroot()
        reason = e.find("model/reason_for_stopping").text
        anchor_seq_id = ""

        # no motif found for given e-value cutoff :-(
        if "Stopped because motif E-value > " in reason:
            if VERBOSE_DEBUG:
                logging.debug("MEME: motif " + mprint(motif["plus"], motif["minus"]) + "; e-value exceeds cutoff")

        # motif(s) found :-)
        elif "Stopped because requested number of motifs (1) found" in reason:

            # find anchor genes' sequence_id
            training_set = e.findall("training_set/sequence")  # all promoter sequences passed to MEME
            for element in training_set:
                if "__ANCHOR" in element.attrib["name"]:
                    anchor_seq_id = element.attrib["id"]  # e.g. id=sequence_1

            # only accept motifs which occur in the anchor genes promoter
            contributing_sites = e.findall("motifs/motif/contributing_sites/contributing_site")  # sequences which contributed to the motif
            if anchor_seq_id in map(lambda site: site.attrib["sequence_id"], contributing_sites):
                # save motif score
                motif["score"] = e.find("motifs/motif").attrib["e_value"]  # one motif, didn't ask MEME for more

                # save sequence sites which represent the motif
                motif["seqs"] = ["".join(map(lambda letter: letter.attrib["letter_id"], site.findall("site/letter_ref")))
                                 for site in contributing_sites]
                # write sites to fasta file
                with open(os.path.join(meme_dir, mprint(motif["plus"], motif["minus"]), "binding_sites.fasta"), "w") as handle:
                    handle.write(">{}__{}\n".format(anchor, mprint(motif["plus"], motif["minus"])))
                    handle.write("\n".join(motif["seqs"]))
                if VERBOSE_DEBUG:
                    logging.debug("MEME: motif %s; e-value = %s", mprint(motif["plus"], motif["minus"]), motif["score"])
            else:
                if VERBOSE_DEBUG:
                    logging.debug("MEME: motif %s; does not occur in anchor gene promoter", mprint(motif["plus"], motif["minus"]))

        # unexpected reason, don't know why MEME stopped :-$
        else:
            logging.error("MEME stopped unexpectedly (reason: " + reason + ")")

    return list(filter(lambda m: m["score"] is not None, promoter_sets))


def filter_fimo_results(motifs, fimo_dir: str, promoters: List[Promoter], anchor_promoter: Promoter):
    """Analyse and filter FIMO results"""

    for motif in motifs:
        motif["hits"] = {}
        with open(os.path.join(fimo_dir, mprint(motif["plus"], motif["minus"]), "fimo.txt"), "r") as handle:
            table = csv.reader(handle, delimiter="\t")
            for row in table:
                if not row[0].startswith("#"):  # skip comment lines
                    seq_id = row[1]
                    if seq_id in motif["hits"]:
                        motif["hits"][seq_id] += 1
                    else:
                        motif["hits"][seq_id] = 1

        # write binding sites per promoter to file
        with open(os.path.join(fimo_dir, mprint(motif["plus"], motif["minus"]), "bs_per_promoter.csv"), "w") as handle:
            table = csv.writer(handle, delimiter="\t", lineterminator="\n")
            table.writerow(["#", "promoter", "binding sites"])  # table head
            for i, promoter in enumerate(promoters):
                promoter = promoter.get_id()
                if promoter in motif["hits"]:
                    table.writerow([i+1, promoter, motif["hits"][promoter]])
                else:
                    table.writerow([i+1, promoter, 0])

        percentage = len(motif["hits"]) / len(promoters) * 100
        if percentage == 0.0:
            # too low
            if VERBOSE_DEBUG:
                logging.debug("FIMO: motif %s; occurs in %d promoters (no hits)",
                              mprint(motif["plus"], motif["minus"]), len(motif["hits"]))
            motif["hits"] = None
        elif percentage > MAX_PERCENTAGE:
            # too high
            if VERBOSE_DEBUG:
                logging.debug("FIMO: %s; occurs in %d promoters; %.2f%% of all promoters (too many)",
                              mprint(motif["plus"], motif["minus"]), len(motif["hits"]), percentage)
            motif["hits"] = None
        elif promoters[anchor_promoter].get_id() not in motif["hits"]:  # not in achor promoter
            # no site in anchor promoter
            if VERBOSE_DEBUG:
                logging.debug("FIMO: motif %s; not hits in the promoter of the anchor gene",
                              mprint(motif["plus"], motif["minus"]))
            motif["hits"] = None
        else:
            # everything ok
            if VERBOSE_DEBUG:
                logging.debug("FIMO: motif %s; occurs in %d promoters; %.2f%% of all promoters",
                              mprint(motif["plus"], motif["minus"]), len(motif["hits"]), percentage)

    return list(filter(lambda m: m["hits"] is not None, motifs))


def get_islands(anchor_promoter, motifs, promoters):
    """Find islands of binding sites (previously found by FIMO) around anchor gene to define cluster borders"""
    islands = []
    motifs = list(motifs)
    for motif in motifs:
        # create list with binding sites per promoter
        bs_per_promoter = [0] * len(promoters)  # first: set number of binding sites to 0
        for i, promoter in enumerate(promoters):
            if promoter.get_id() in motif["hits"]:  # second: set actual number of binding sites, if any
                bs_per_promoter[i] = motif["hits"][promoter.get_id()]

        # upstream
        start = anchor_promoter  # init upstream cluster border
        i = anchor_promoter  # init position of anchor gene's promoter
        while i > 0:

            # promoter with binding site
            # … 1 …
            if bs_per_promoter[i-1] >= 1:
                start -= 1

            # no binding site, gap with length 1
            # … 1 0 1  …
            elif (i - 2 >= 0
                  and MAX_GAP_LENGTH >= 1
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i-1] == 0
                  and bs_per_promoter[i-2] >= 1):
                start -= 2
                i -= 1

            # no binding site, gap with length 2
            # … 1 0 0 1  …
            elif (i - 3 >= 0
                  and MAX_GAP_LENGTH >= 2
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i-1] == 0
                  and bs_per_promoter[i-2] == 0
                  and bs_per_promoter[i-3] >= 1):
                start -= 3
                i -= 2

            # no binding site, gap with length 3
            # … 1 0 0 0 1  …
            elif (i - 4 >= 0
                  and MAX_GAP_LENGTH >= 3
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i-1] == 0
                  and bs_per_promoter[i-2] == 0
                  and bs_per_promoter[i-3] == 0
                  and bs_per_promoter[i-4] >= 1):
                start -= 4
                i -= 3

            # no binding site, gap with length 4
            # … 1 0 0 0 0 1  …
            elif (i - 5 >= 0
                  and MAX_GAP_LENGTH >= 4
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i-1] == 0
                  and bs_per_promoter[i-2] == 0
                  and bs_per_promoter[i-3] == 0
                  and bs_per_promoter[i-4] == 0
                  and bs_per_promoter[i-5] >= 1):
                start -= 5
                i -= 4

            # no binding site, gap with length 5
            # … 1 0 0 0 0 0 1  …
            elif (i - 6 >= 0
                  and MAX_GAP_LENGTH >= 5
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i-1] == 0
                  and bs_per_promoter[i-2] == 0
                  and bs_per_promoter[i-3] == 0
                  and bs_per_promoter[i-4] == 0
                  and bs_per_promoter[i-5] == 0
                  and bs_per_promoter[i-6] >= 1):
                start -= 6
                i -= 5

            # gap too long, stop upstream cluster extension
            else:
                break

            i -= 1

        # downstream
        i = anchor_promoter  # reset position of anchor gene's promoter
        end = anchor_promoter  # init downstream cluster border
        while i < len(bs_per_promoter) - 1:

            # promoter with binding site(s)
            # … 1 …
            if bs_per_promoter[i+1] > 0:
                end += 1

            # no binding site, gap with length 1
            # … 1 0 1  …
            elif (i + 2 < len(bs_per_promoter)
                  and MAX_GAP_LENGTH >= 1
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i+1] == 0
                  and bs_per_promoter[i+2] >= 1):
                end += 2
                i += 1

            # no binding site, gap with length 2
            # … 1 0 0 1  …
            elif (i + 3 < len(bs_per_promoter)
                  and MAX_GAP_LENGTH >= 2
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i+1] == 0
                  and bs_per_promoter[i+2] == 0
                  and bs_per_promoter[i+3] >= 1):
                end += 3
                i += 2

            # no binding site, gap with length 3
            # … 1 0 0 0 1  …
            elif (i + 4 < len(bs_per_promoter)
                  and MAX_GAP_LENGTH >= 3
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i+1] == 0
                  and bs_per_promoter[i+2] == 0
                  and bs_per_promoter[i+3] == 0
                  and bs_per_promoter[i+4] >= 1):
                end += 4
                i += 3

            # no binding site, gap with length 4
            # … 1 0 0 0 0 1  …
            elif (i + 5 < len(bs_per_promoter)
                  and MAX_GAP_LENGTH >= 4
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i+1] == 0
                  and bs_per_promoter[i+2] == 0
                  and bs_per_promoter[i+3] == 0
                  and bs_per_promoter[i+4] == 0
                  and bs_per_promoter[i+5] >= 1):
                end += 5
                i += 4

            # no binding site, gap with length 5
            # … 1 0 0 0 0 0 1  …
            elif (i + 6 < len(bs_per_promoter)
                  and MAX_GAP_LENGTH >= 5
                  and bs_per_promoter[i] >= 1
                  and bs_per_promoter[i+1] == 0
                  and bs_per_promoter[i+2] == 0
                  and bs_per_promoter[i+3] == 0
                  and bs_per_promoter[i+4] == 0
                  and bs_per_promoter[i+5] == 0
                  and bs_per_promoter[i+6] >= 1):
                end += 6
                i += 5

            # gap too long, stop downstream cluster extension
            else:
                break

            i += 1
        if VERBOSE_DEBUG:
            logging.debug("Island %s -- %s (motif %s)", promoters[start].get_id(),
                          promoters[end].get_id(), mprint(motif["plus"], motif["minus"]))
        islands.append({"start": promoters[start], "end": promoters[end], "motif": motif})

    return islands


def sort_by_abundance(islands):
    """Sort upstream (start) and downstream (end) borders of islands by abundance"""
    # count border abundance
    # start/end are treated independently!
    starts = {}
    ends = {}
    for i in islands:
        if i["start"].gene_name in starts:
            starts[i["start"].gene_name]["abund"] += 1
        else:
            starts[i["start"].gene_name] = {"abund": 1}

        if i["end"].get_gene_names()[-1] in ends:
            ends[i["end"].get_gene_names()[-1]]["abund"] += 1
        else:
            ends[i["end"].get_gene_names()[-1]] = {"abund": 1}

        # keep track of motif score --> to sort by score if same abundance occurs more than once
        # AND
        # save motif "names" (plus, minus) --> additional info for showing the results later on
        if "mscore" not in starts[i["start"].gene_name] or float(i["motif"]["score"]) < float(starts[i["start"].gene_name]["mscore"]):
            starts[i["start"].gene_name]["mscore"] = i["motif"]["score"]
            starts[i["start"].gene_name]["plus"] = i["motif"]["plus"]
            starts[i["start"].gene_name]["minus"] = i["motif"]["minus"]
        if "mscore" not in ends[i["end"].get_gene_names()[-1]] or float(i["motif"]["score"]) < float(ends[i["end"].get_gene_names()[-1]]["mscore"]):
            ends[i["end"].get_gene_names()[-1]]["mscore"] = i["motif"]["score"]
            ends[i["end"].get_gene_names()[-1]]["plus"] = i["motif"]["plus"]
            ends[i["end"].get_gene_names()[-1]]["minus"] = i["motif"]["minus"]

    # compute sum of start and end abundance, remove duplicates, sort descending
    abundances_sum_sorted = sorted(set([s["abund"] + e["abund"] for s in starts.values() for e in ends.values()]), reverse=True)
    # compute sum of start and end motif score, remove duplicates, sort ascending
    scores_sum_sorted = sorted(set([float(s["mscore"]) + float(e["mscore"]) for s in starts.values() for e in ends.values()]))
    # sort by value (=abundance) of start, descending
    starts_sorted = sorted(starts, key=lambda x: starts[x]["abund"], reverse=True)
    # sort by value (=abundance) of end, descending
    ends_sorted = sorted(ends, key=lambda x: ends[x]["abund"], reverse=True)

    clusters = []
    for abundance in abundances_sum_sorted:
        # list from highest (best) to lowest (worst) abundance
        for score in scores_sum_sorted:
            # list from lowest (best) to highest (worst) motif score/e-value
            for start in starts_sorted:
                for end in ends_sorted:
                    if (starts[start]["abund"] + ends[end]["abund"] == abundance
                            and float(starts[start]["mscore"]) + float(ends[end]["mscore"]) == score):
                        clusters.append({
                            "start": {
                                "gene": start,
                                "abundance": starts[start]["abund"],
                                "score": starts[start]["mscore"],
                                "plus": starts[start]["plus"],
                                "minus": starts[start]["minus"],
                            },
                            "end": {
                                "gene": end,
                                "abundance": ends[end]["abund"],
                                "score": ends[end]["mscore"],
                                "plus": ends[end]["plus"],
                                "minus": ends[end]["minus"],
                            },
                        })
                        if VERBOSE_DEBUG:
                            logging.debug("Upstream border:   gene %s; abundance %s; motif %s; score %s",
                                          start,
                                          starts[start]["abund"],
                                          mprint(starts[start]["plus"], starts[start]["minus"]),
                                          starts[start]["mscore"])
                            logging.debug("Downstream border: gene %s; abundance %s; motif %s; score %s",
                                          end,
                                          ends[end]["abund"],
                                          mprint(ends[end]["plus"], ends[end]["minus"]),
                                          ends[end]["mscore"])
                            logging.debug("Total abundance %s, total score %.1e",
                                          abundance, score)

    return clusters


def check_cluster_predictions(cluster_predictions, record: Record, promoters, ignored_genes):
    """Get some more infos about each cluster prediction and check if it seems to be sane"""
    checked_predictions = []
    for cp, prediction in enumerate(cluster_predictions):
        sane = True

        # find indices of first and last GENE of the cluster prediction in all genes
        all_gene_names = [gene.get_name() for gene in sorted(record.get_genes(), key=lambda x: x.location.start)]

        start_index_genes = None
        end_index_genes = None
        for i, gene_name in enumerate(all_gene_names):
            if not start_index_genes and prediction["start"]["gene"] == gene_name:
                start_index_genes = i
            if not end_index_genes and prediction["end"]["gene"] == gene_name:
                end_index_genes = i
            if start_index_genes and end_index_genes:
                break

        # find indices of first and last PROMOTER of the cluster prediction in all promoters
        start_index_promoters = None
        end_index_promoters = None
        for i, promoter in enumerate(promoters):
            if not start_index_promoters and prediction["start"]["gene"] in promoter.get_gene_names():
                start_index_promoters = i
            if not end_index_promoters and prediction["end"]["gene"] in promoter.get_gene_names():
                end_index_promoters = i
            if start_index_promoters and end_index_promoters:
                break

        prediction["start"]["promoter"] = promoters[start_index_promoters].get_id()
        prediction["end"]["promoter"] = promoters[end_index_promoters].get_id()
        prediction["genes"] = end_index_genes - start_index_genes + 1
        prediction["promoters"] = end_index_promoters - start_index_promoters + 1
        if VERBOSE_DEBUG:
            if cp == 0:
                logging.debug("Best prediction (most abundant): %r -- %r",
                             prediction["start"]["gene"], prediction["end"]["gene"])
            else:
                logging.debug("Alternative prediction (%s): %r -- %r",
                             cp, prediction["start"]["gene"], prediction["end"]["gene"])

        # warn if cluster prediction right at or next to record (~ contig) border
        if start_index_genes < 10:
            if VERBOSE_DEBUG:
                logging.debug(
                    "Upstream cluster border located at or next to sequence record border, prediction could have been truncated by record border")
            sane = False
        if end_index_genes > len(all_gene_names) - 10:
            if VERBOSE_DEBUG:
                logging.debug(
                    "Downstream cluster border located at or next to sequence record border, prediction could have been truncated by record border")
            sane = False

        # warn if cluster prediction too short (includes less than 3 genes)
        if prediction["genes"] < 3:
            if VERBOSE_DEBUG:
                logging.debug("Cluster is very short (less than 3 genes). Prediction may be questionable.")
            sane = False

        # warn if ignored gene (overlapping with anthor gene, see ignore_overlapping()) would have been part of the cluster
        for ignored_gene in ignored_genes:
            if ignored_gene.get_name() in all_gene_names[start_index_genes: end_index_genes + 1]:
                if VERBOSE_DEBUG:
                    logging.debug("Gene %r is part of the predicted cluster,"
                                 " but it is overlapping with another gene and was ignored", ignored_gene)
                    logging.debug("Gene %r could have affected the cluster prediction", ignored_gene)
                # sane = False # uncomment if you want alternatives for predictions with ignored genes, too # TODO
                break

        checked_predictions.append(prediction)

        if sane:
            break

    return checked_predictions


def cleanup_outdir(anchor_genes, cluster_predictions, options):
    """Delete unnecessary files to free disk space"""
    all_motifs = set()
    for motif in _plus_minus:
        all_motifs.add(mprint(motif["plus"], motif["minus"]))

    for anchor in anchor_genes:
        if anchor in cluster_predictions:
            used_motifs = set()
            for cluster in cluster_predictions[anchor]:
                used_motifs.add(mprint(cluster["start"]["plus"], cluster["start"]["minus"]))
                used_motifs.add(mprint(cluster["end"]["plus"], cluster["end"]["minus"]))
            unused_motifs = all_motifs.difference(used_motifs)
            # only remove directories from "unused" motifs (no cluster prediction)
            for directory in unused_motifs:
                shutil.rmtree(os.path.join(options.output_dir, "meme", anchor, directory), ignore_errors=True)
                shutil.rmtree(os.path.join(options.output_dir, "fimo", anchor, directory), ignore_errors=True)
        else:
            # all motifs are "unused" (not a single prediction for this anchor gene)
            # --> remove anchor genes directory, including all motif subdirectories
            shutil.rmtree(os.path.join(options.output_dir, "meme", anchor), ignore_errors=True)
            shutil.rmtree(os.path.join(options.output_dir, "fimo", anchor), ignore_errors=True)


# storage methods
def store_promoters(promoters, record: Record):
    """Store information about promoter sequences to a SeqRecord"""
    for promoter in promoters:
        # remember to account for 0-indexed start location
        new_feature = SeqFeature(FeatureLocation(promoter.start - 1, promoter.end),
                                 type="promoter")
        new_feature.qualifiers = {
            "locus_tag": promoter.get_gene_names(),  # already a list with one or two elements
            "seq": [str(promoter.seq)],  # TODO save string or Seq object?
        }

        if isinstance(promoter, CombinedPromoter):
            new_feature.qualifiers["note"] = ["bidirectional promoter"]

        logging.critical("adding promoters based on biopython features")
        secmet_version = Feature.from_biopython(new_feature)
        secmet_version.created_by_antismash = True

        record.add_feature(secmet_version)


def create_cluster_borders(anchor, clusters, record: Record) -> List[ClusterBorder]:
    """ Create the predicted ClusterBorders """
    if not clusters:
        return []
    borders = []
    for i, cluster in enumerate(clusters):
        # cluster borders returned by hmmdetect are based on CDS features
        # see find_clusters() in hmmdetect's __init__.py
        # in contrast, cluster borders returned by cassis are based on gene features
        # --> hmmdetect derived clusters have exact loctions, like the CDSs have
        # --> cassis derived clusters may have fuzzy locations, like the genes have
        #
        # utils.get_all_features_of_type_with_query() returns a list
        # there should be no second gene with the same locus tag
        # --> always take the first [0] element of the return value
        left_name = cluster["start"]["gene"]
        right_name = cluster["end"]["gene"]
        left = None
        right = None
        for gene in record.get_genes():
            if gene.get_name() == left_name:
                left = gene
            if gene.get_name() == right_name:
                right = gene
            if left and right:
                break

        new_feature = SeqFeature(
            FeatureLocation(left.location.start, right.location.end), type="cluster_border")
        new_feature.qualifiers = {
            "aStool": ["cassis"],
            "anchor": [anchor],
            "abundance": [cluster["start"]["abundance"] + cluster["end"]["abundance"]],
            "motif_score": ["{:.1e}".format(float(cluster["start"]["score"]) + float(cluster["end"]["score"]))],
            "gene_left": [cluster["start"]["gene"]],
            "promoter_left": [cluster["start"]["promoter"]],
            "abundance_left": [cluster["start"]["abundance"]],
            "motif_left": [mprint(cluster["start"]["plus"], cluster["start"]["minus"])],
            "motif_score_left": ["{:.1e}".format(float(cluster["start"]["score"]))],
            "gene_right": [cluster["end"]["gene"]],
            "promoter_right": [cluster["end"]["promoter"]],
            "abundance_right": [cluster["end"]["abundance"]],
            "motif_right": [mprint(cluster["end"]["plus"], cluster["end"]["minus"])],
            "motif_score_right": ["{:.1e}".format(float(cluster["end"]["score"]))],
            "genes": [cluster["genes"]],
            "promoters": [cluster["promoters"]],
        }

        if i == 0:
            new_feature.qualifiers["note"] = ["best prediction (most abundant) for anchor gene {}".format(anchor)]
        else:
            new_feature.qualifiers["note"] = ["alternative prediction ({}) for anchor gene {}".format(i, anchor)]

        logging.critical("still constructing biopython features for cluster borders")
        new_feature = ClusterBorder.from_biopython(new_feature)
        borders.append(new_feature)
    return borders
